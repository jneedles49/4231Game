using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class ShadowObject : MonoBehaviour
{
    [SerializeField] private GameObject ConnectedObject;
    private PickupBehavior ConnectedObj_PickupBehavior;

    [SerializeField] private bool Move_X;
    [SerializeField] private bool Move_Y;
    [SerializeField] private bool Move_Z;

    private float X_Constant;
    private float Y_Constant;
    private float Z_Constant;

    private float delta_x;
    private float delta_y;
    private float delta_z;

    private Rigidbody rg;
    private Vector3 velocity = Vector3.zero;
    private Transform trans;

    //List containing all of the new gameobjects that are generated by the shadow object.
    [Header("Created Shadow Collider")]
    [SerializeField] private GameObject Wall_Collider;
    [SerializeField] private GameObject Button_Collider; 
    private List<GameObject> ShadowColliders = new List<GameObject>();
    private List<GameObject> Collision_History = new List<GameObject>();

    // Start is called before the first frame update
    void Start()
    {
        //We get our constants once the game starts and then we are able to dynamically constrain our object if we need to
        X_Constant = this.transform.position.x;
        Y_Constant = this.transform.position.y;
        Z_Constant = this.transform.position.z;
        rg = this.GetComponent<Rigidbody>();
	trans = this.transform;

        //Connecting shadow objcet to pickup object
        ConnectedObj_PickupBehavior = ConnectedObject.GetComponent<PickupBehavior>();

    }

    void FixedUpdate()
    {

        //These will become our paramaters when we create our new Vector3 position
        float new_X;
        float new_Y;
        float new_Z;

        //We take the connected objects position once every updeate 
        Vector3 ConnectedObj_position = ConnectedObject.transform.position;

        //We set our new X,Y,Z to the connected objects corresponding value or the constant
        if(Move_X){ 
            new_X = ConnectedObj_position.x;
        }
        else new_X = X_Constant; 

        if(Move_Y){
            new_Y = ConnectedObj_position.y;
        }
        else new_Y = Y_Constant; 

        if(Move_Z){
            new_Z = ConnectedObj_position.z;
        }
        else new_Z = Z_Constant; 

        //This is our new position we will be moving to
        Vector3 new_pos = new Vector3(new_X, new_Y, new_Z); 


	Ray Direction = new Ray(trans.position, Vector3.Normalize(new_pos) * 2);


	Debug.DrawRay(Direction.origin, Direction.direction, Color.blue);

        //This is the actual movement from where we are now to where we need to go
        trans.position = new_pos; 

    }


    
    private void OnCollisionEnter(Collision other) {

        Debug.Log("Collided");

	switch(other.gameObject.tag){

		case "ShadowWall":
			Make_Collider(other.gameObject, Wall_Collider);
			break;
		case "ShadowButton":
            Make_Collider(other.gameObject, Button_Collider);
            break;
        case "Ground":
			Delete_Colliders();
			break;
	}

    }

    private void OnCollisionExit(Collision other) {

        Debug.Log("Left Collision");


    }

    private void Make_Collider(GameObject Collision_Object, GameObject collider){
	
	    bool Already_Collided = false;

	    //See if we have already collided with this object
	    for(int i = 0; i < Collision_History.Count; i++){

		    if(Collision_Object == Collision_History[i]){
			    Already_Collided = true;
			    break;
		    }

	    }

	    if(Already_Collided){
		    Debug.Log("WE ALREADY COLLIDED WITH THIS OBJECT");
		    return;
	    }

	    Debug.Log("Making a collider object: " + Collision_Object.name);
	    Transform Collision_Transform = Collision_Object.transform;

	    Debug.Log("Position: " + Collision_Transform.position);
	    Debug.Log("Rotation: " + Collision_Transform.rotation);


	    GameObject Collision_Instance = Instantiate(collider);
	    Collision_Instance.transform.position = Collision_Transform.position;
	    Collision_Instance.transform.rotation = Collision_Transform.rotation;

	    ShadowCollider Collision_Instance_Script = Collision_Instance.GetComponent<ShadowCollider>();
	    Collision_Instance_Script.Target_Transform = ConnectedObject.transform; //Interactable object transform



	    ShadowColliders.Add(Collision_Instance);
	    Collision_History.Add(Collision_Object);


    }

    //Delete Colliders clear shadow colliders list, and the collision history, when the interactable object is dropped
    private void Delete_Colliders(){

	    //If we didn't collide with anything then we didn't make anything
	    if(Collision_History.Count == 0){
		    Debug.Log("Didn't Collide with anything yet nothing to delete");
		    return;
	    }

	    //Delete Memory of colliders
	    Collision_History.Clear();

	    //Delete all instantiated Colliders
	    for(int i = 0; i < ShadowColliders.Count; i++){

		    Destroy(ShadowColliders[i]);
		    Debug.Log("Destroyed: " + ShadowColliders[i]);

	    }	

	    //Clear Instantiated List
	    ShadowColliders.Clear();

	    Debug.Log("Cleared Shadow Collider Memory");

    }

}
